import type { KnowledgeResult } from '../types/engine-contracts';

/**
 * Query plan generated by QueryPlanner
 */
export interface QueryPlan {
  /**
   * Original query text
   */
  originalQuery: string;
  
  /**
   * Sub-queries to execute
   */
  subqueries: SubQuery[];
  
  /**
   * Estimated complexity score (0-1)
   */
  complexityScore: number;
  
  /**
   * Dependencies between sub-queries (for sequential execution if needed)
   */
  dependencies?: Map<number, number[]>;
}

/**
 * Single sub-query in a reasoning plan
 */
export interface SubQuery {
  /**
   * Query text
   */
  text: string;
  
  /**
   * Priority (higher = more important)
   */
  priority: number;
  
  /**
   * Group ID for parallel execution
   */
  groupId: number;
  
  /**
   * Estimated relevance to original query
   */
  relevance: number;
}

/**
 * Reasoning execution context
 */
export interface ReasoningContext {
  /**
   * Current depth in reasoning chain
   */
  depth: number;
  
  /**
   * Maximum allowed depth
   */
  maxDepth: number;
  
  /**
   * Query path (to detect cycles)
   */
  queryPath: string[];
  
  /**
   * Total queries executed so far
   */
  totalQueries: number;
  
  /**
   * Maximum total queries allowed
   */
  maxTotalQueries: number;
  
  /**
   * Tokens used so far
   */
  tokensUsed: number;
  
  /**
   * Maximum tokens per depth level
   */
  maxTokensPerDepth: number;
}

/**
 * Reasoning result
 */
export interface ReasoningResult extends KnowledgeResult {
  /**
   * Reasoning metadata
   */
  reasoning?: {
    /**
     * Complexity score
     */
    complexityScore: number;
    
    /**
     * Query plan used
     */
    plan: QueryPlan;
    
    /**
     * Execution depth
     */
    depth: number;
    
    /**
     * Number of sub-queries executed
     */
    subqueriesCount: number;
    
    /**
     * Number of parallel executions
     */
    parallelExecuted: number;
    
    /**
     * Timing metrics
     */
    timing: {
      planningTimeMs: number;
      executionTimeMs: number;
      synthesisTimeMs: number;
      totalTimeMs: number;
    };
    
    /**
     * Tokens saved compared to non-reasoning approach
     */
    tokensSaved?: number;
    
    /**
     * Quality score (from feedback)
     */
    qualityScore?: number;
  };
}

/**
 * Complexity detection result
 */
export interface ComplexityResult {
  /**
   * Complexity score (0-1)
   */
  score: number;
  
  /**
   * Reasons for complexity assessment
   */
  reasons: string[];
  
  /**
   * Whether reasoning is recommended
   */
  needsReasoning: boolean;
}




